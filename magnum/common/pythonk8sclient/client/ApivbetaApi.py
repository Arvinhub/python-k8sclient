#!/usr/bin/env python
"""
ApivbetaApi.py
Copyright 2015 Reverb Technologies, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

NOTE: This class is auto generated by the swagger code generator program. Do not edit the class manually.
"""
import sys
import os
import urllib

from models import *


class ApivbetaApi(object):

    def __init__(self, apiClient):
      self.apiClient = apiClient

    
    
    def listEndpoints(self, **kwargs):
        """list or watch objects of kind Endpoints

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_EndpointsList
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listEndpoints" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/endpoints'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_EndpointsList')
        return responseObject
        
        
        
    
    def listEvent(self, **kwargs):
        """list or watch objects of kind Event

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_EventList
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listEvent" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/events'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_EventList')
        return responseObject
        
        
        
    
    def listLimitRange(self, **kwargs):
        """list or watch objects of kind LimitRange

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_LimitRangeList
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listLimitRange" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/limitranges'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_LimitRangeList')
        return responseObject
        
        
        
    
    def listNamespace(self, **kwargs):
        """list or watch objects of kind Namespace

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_NamespaceList
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listNamespace" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_NamespaceList')
        return responseObject
        
        
        
    
    def createNamespace(self, **kwargs):
        """create a Namespace

        Args:
            
            body, V1beta3_Namespace:  (required)
            
            
        
        Returns: 
        """

        allParams = ['body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createNamespace" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def createBinding(self, **kwargs):
        """create a Binding

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_Binding:  (required)
            
            
        
        Returns: 
        """

        allParams = ['namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createBinding" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/bindings'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def listEndpoints(self, **kwargs):
        """list or watch objects of kind Endpoints

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_EndpointsList
        """

        allParams = ['namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listEndpoints" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/endpoints'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_EndpointsList')
        return responseObject
        
        
        
    
    def createEndpoints(self, **kwargs):
        """create a Endpoints

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_Endpoints:  (required)
            
            
        
        Returns: 
        """

        allParams = ['namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createEndpoints" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/endpoints'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def readEndpoints(self, **kwargs):
        """read the specified Endpoints

        Args:
            
            name, str: name of the Endpoints (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: v1beta3_Endpoints
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method readEndpoints" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/endpoints/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_Endpoints')
        return responseObject
        
        
        
    
    def replaceEndpoints(self, **kwargs):
        """replace the specified Endpoints

        Args:
            
            name, str: name of the Endpoints (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_Endpoints:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method replaceEndpoints" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/endpoints/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def deleteEndpoints(self, **kwargs):
        """delete a Endpoints

        Args:
            
            name, str: name of the Endpoints (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_DeleteOptions:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method deleteEndpoints" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/endpoints/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def patchEndpoints(self, **kwargs):
        """partially update the specified Endpoints

        Args:
            
            name, str: name of the Endpoints (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_Endpoints:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method patchEndpoints" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/endpoints/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PATCH'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = 'application/json-patch+json,application/merge-patch+json,application/strategic-merge-patch+json,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def listEvent(self, **kwargs):
        """list or watch objects of kind Event

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_EventList
        """

        allParams = ['namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listEvent" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/events'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_EventList')
        return responseObject
        
        
        
    
    def createEvent(self, **kwargs):
        """create a Event

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_Event:  (required)
            
            
        
        Returns: 
        """

        allParams = ['namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createEvent" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/events'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def readEvent(self, **kwargs):
        """read the specified Event

        Args:
            
            name, str: name of the Event (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: v1beta3_Event
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method readEvent" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/events/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_Event')
        return responseObject
        
        
        
    
    def replaceEvent(self, **kwargs):
        """replace the specified Event

        Args:
            
            name, str: name of the Event (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_Event:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method replaceEvent" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/events/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def deleteEvent(self, **kwargs):
        """delete a Event

        Args:
            
            name, str: name of the Event (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method deleteEvent" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/events/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def patchEvent(self, **kwargs):
        """partially update the specified Event

        Args:
            
            name, str: name of the Event (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_Event:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method patchEvent" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/events/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PATCH'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = 'application/json-patch+json,application/merge-patch+json,application/strategic-merge-patch+json,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def listLimitRange(self, **kwargs):
        """list or watch objects of kind LimitRange

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_LimitRangeList
        """

        allParams = ['namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listLimitRange" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/limitranges'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_LimitRangeList')
        return responseObject
        
        
        
    
    def createLimitRange(self, **kwargs):
        """create a LimitRange

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_LimitRange:  (required)
            
            
        
        Returns: 
        """

        allParams = ['namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createLimitRange" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/limitranges'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def readLimitRange(self, **kwargs):
        """read the specified LimitRange

        Args:
            
            name, str: name of the LimitRange (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: v1beta3_LimitRange
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method readLimitRange" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/limitranges/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_LimitRange')
        return responseObject
        
        
        
    
    def replaceLimitRange(self, **kwargs):
        """replace the specified LimitRange

        Args:
            
            name, str: name of the LimitRange (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_LimitRange:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method replaceLimitRange" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/limitranges/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def deleteLimitRange(self, **kwargs):
        """delete a LimitRange

        Args:
            
            name, str: name of the LimitRange (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method deleteLimitRange" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/limitranges/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def patchLimitRange(self, **kwargs):
        """partially update the specified LimitRange

        Args:
            
            name, str: name of the LimitRange (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_LimitRange:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method patchLimitRange" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/limitranges/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PATCH'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = 'application/json-patch+json,application/merge-patch+json,application/strategic-merge-patch+json,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def listPersistentVolumeClaim(self, **kwargs):
        """list or watch objects of kind PersistentVolumeClaim

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_PersistentVolumeClaimList
        """

        allParams = ['namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listPersistentVolumeClaim" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/persistentvolumeclaims'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_PersistentVolumeClaimList')
        return responseObject
        
        
        
    
    def createPersistentVolumeClaim(self, **kwargs):
        """create a PersistentVolumeClaim

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_PersistentVolumeClaim:  (required)
            
            
        
        Returns: 
        """

        allParams = ['namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createPersistentVolumeClaim" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/persistentvolumeclaims'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def readPersistentVolumeClaim(self, **kwargs):
        """read the specified PersistentVolumeClaim

        Args:
            
            name, str: name of the PersistentVolumeClaim (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: v1beta3_PersistentVolumeClaim
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method readPersistentVolumeClaim" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/persistentvolumeclaims/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_PersistentVolumeClaim')
        return responseObject
        
        
        
    
    def replacePersistentVolumeClaim(self, **kwargs):
        """replace the specified PersistentVolumeClaim

        Args:
            
            name, str: name of the PersistentVolumeClaim (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_PersistentVolumeClaim:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method replacePersistentVolumeClaim" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/persistentvolumeclaims/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def deletePersistentVolumeClaim(self, **kwargs):
        """delete a PersistentVolumeClaim

        Args:
            
            name, str: name of the PersistentVolumeClaim (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_DeleteOptions:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method deletePersistentVolumeClaim" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/persistentvolumeclaims/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def patchPersistentVolumeClaim(self, **kwargs):
        """partially update the specified PersistentVolumeClaim

        Args:
            
            name, str: name of the PersistentVolumeClaim (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_PersistentVolumeClaim:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method patchPersistentVolumeClaim" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/persistentvolumeclaims/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PATCH'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = 'application/json-patch+json,application/merge-patch+json,application/strategic-merge-patch+json,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def listPod(self, **kwargs):
        """list or watch objects of kind Pod

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_PodList
        """

        allParams = ['namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listPod" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/pods'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_PodList')
        return responseObject
        
        
        
    
    def createPod(self, **kwargs):
        """create a Pod

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_Pod:  (required)
            
            
        
        Returns: 
        """

        allParams = ['namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createPod" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/pods'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        return response

        
        
        
    
    def readPod(self, **kwargs):
        """read the specified Pod

        Args:
            
            name, str: name of the Pod (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: v1beta3_Pod
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method readPod" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/pods/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_Pod')
        return responseObject
        
        
        
    
    def replacePod(self, **kwargs):
        """replace the specified Pod

        Args:
            
            name, str: name of the Pod (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_Pod:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method replacePod" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/pods/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        return response

        
        
        
    
    def deletePod(self, **kwargs):
        """delete a Pod

        Args:
            
            name, str: name of the Pod (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_DeleteOptions:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method deletePod" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/pods/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def patchPod(self, **kwargs):
        """partially update the specified Pod

        Args:
            
            name, str: name of the Pod (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_Pod:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method patchPod" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/pods/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PATCH'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = 'application/json-patch+json,application/merge-patch+json,application/strategic-merge-patch+json,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def createBinding(self, **kwargs):
        """create a Binding

        Args:
            
            name, str: name of the Binding (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_Binding:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createBinding" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/pods/{name}/binding'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def readPodLogOptions(self, **kwargs):
        """read the specified PodLogOptions

        Args:
            
            name, str: name of the PodLogOptions (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: v1beta3_PodLogOptions
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method readPodLogOptions" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/pods/{name}/log'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_PodLogOptions')
        return responseObject
        
        
        
    
    def replacePod(self, **kwargs):
        """replace the specified Pod

        Args:
            
            name, str: name of the Pod (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_Pod:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method replacePod" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/pods/{name}/status'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def listReplicationController(self, **kwargs):
        """list or watch objects of kind ReplicationController

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_ReplicationControllerList
        """

        allParams = ['namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listReplicationController" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/replicationcontrollers'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_ReplicationControllerList')
        return responseObject
        
        
        
    
    def createReplicationController(self, **kwargs):
        """create a ReplicationController

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_ReplicationController:  (required)
            
            
        
        Returns: 
        """

        allParams = ['namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createReplicationController" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/replicationcontrollers'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        return response

        
        
        
    
    def readReplicationController(self, **kwargs):
        """read the specified ReplicationController

        Args:
            
            name, str: name of the ReplicationController (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: v1beta3_ReplicationController
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method readReplicationController" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/replicationcontrollers/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_ReplicationController')
        return responseObject
        
        
        
    
    def replaceReplicationController(self, **kwargs):
        """replace the specified ReplicationController

        Args:
            
            name, str: name of the ReplicationController (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_ReplicationController:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method replaceReplicationController" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/replicationcontrollers/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        return response

        
        
        
    
    def deleteReplicationController(self, **kwargs):
        """delete a ReplicationController

        Args:
            
            name, str: name of the ReplicationController (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_DeleteOptions:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method deleteReplicationController" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/replicationcontrollers/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def patchReplicationController(self, **kwargs):
        """partially update the specified ReplicationController

        Args:
            
            name, str: name of the ReplicationController (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_ReplicationController:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method patchReplicationController" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/replicationcontrollers/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PATCH'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = 'application/json-patch+json,application/merge-patch+json,application/strategic-merge-patch+json,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def listResourceQuota(self, **kwargs):
        """list or watch objects of kind ResourceQuota

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_ResourceQuotaList
        """

        allParams = ['namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listResourceQuota" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/resourcequotas'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_ResourceQuotaList')
        return responseObject
        
        
        
    
    def createResourceQuota(self, **kwargs):
        """create a ResourceQuota

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_ResourceQuota:  (required)
            
            
        
        Returns: 
        """

        allParams = ['namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createResourceQuota" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/resourcequotas'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def readResourceQuota(self, **kwargs):
        """read the specified ResourceQuota

        Args:
            
            name, str: name of the ResourceQuota (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: v1beta3_ResourceQuota
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method readResourceQuota" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/resourcequotas/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_ResourceQuota')
        return responseObject
        
        
        
    
    def replaceResourceQuota(self, **kwargs):
        """replace the specified ResourceQuota

        Args:
            
            name, str: name of the ResourceQuota (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_ResourceQuota:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method replaceResourceQuota" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/resourcequotas/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def deleteResourceQuota(self, **kwargs):
        """delete a ResourceQuota

        Args:
            
            name, str: name of the ResourceQuota (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_DeleteOptions:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method deleteResourceQuota" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/resourcequotas/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def patchResourceQuota(self, **kwargs):
        """partially update the specified ResourceQuota

        Args:
            
            name, str: name of the ResourceQuota (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_ResourceQuota:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method patchResourceQuota" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/resourcequotas/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PATCH'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = 'application/json-patch+json,application/merge-patch+json,application/strategic-merge-patch+json,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def replaceResourceQuota(self, **kwargs):
        """replace the specified ResourceQuota

        Args:
            
            name, str: name of the ResourceQuota (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_ResourceQuota:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method replaceResourceQuota" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/resourcequotas/{name}/status'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def listSecret(self, **kwargs):
        """list or watch objects of kind Secret

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_SecretList
        """

        allParams = ['namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listSecret" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/secrets'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_SecretList')
        return responseObject
        
        
        
    
    def createSecret(self, **kwargs):
        """create a Secret

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_Secret:  (required)
            
            
        
        Returns: 
        """

        allParams = ['namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createSecret" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/secrets'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def readSecret(self, **kwargs):
        """read the specified Secret

        Args:
            
            name, str: name of the Secret (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: v1beta3_Secret
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method readSecret" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/secrets/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_Secret')
        return responseObject
        
        
        
    
    def replaceSecret(self, **kwargs):
        """replace the specified Secret

        Args:
            
            name, str: name of the Secret (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_Secret:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method replaceSecret" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/secrets/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def deleteSecret(self, **kwargs):
        """delete a Secret

        Args:
            
            name, str: name of the Secret (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method deleteSecret" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/secrets/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def patchSecret(self, **kwargs):
        """partially update the specified Secret

        Args:
            
            name, str: name of the Secret (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_Secret:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method patchSecret" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/secrets/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PATCH'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = 'application/json-patch+json,application/merge-patch+json,application/strategic-merge-patch+json,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def listService(self, **kwargs):
        """list or watch objects of kind Service

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_ServiceList
        """

        allParams = ['namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listService" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/services'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_ServiceList')
        return responseObject
        
        
        
    
    def createService(self, **kwargs):
        """create a Service

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_Service:  (required)
            
            
        
        Returns: 
        """

        allParams = ['namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createService" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/services'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        return response

        
        
        
    
    def readService(self, **kwargs):
        """read the specified Service

        Args:
            
            name, str: name of the Service (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: v1beta3_Service
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method readService" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/services/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_Service')
        return responseObject
        
        
        
    
    def replaceService(self, **kwargs):
        """replace the specified Service

        Args:
            
            name, str: name of the Service (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_Service:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method replaceService" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/services/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        return response

        
        
        
    
    def deleteService(self, **kwargs):
        """delete a Service

        Args:
            
            name, str: name of the Service (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method deleteService" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/services/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def patchService(self, **kwargs):
        """partially update the specified Service

        Args:
            
            name, str: name of the Service (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            body, V1beta3_Service:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method patchService" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{namespaces}/services/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PATCH'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = 'application/json-patch+json,application/merge-patch+json,application/strategic-merge-patch+json,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def readNamespace(self, **kwargs):
        """read the specified Namespace

        Args:
            
            name, str: name of the Namespace (required)
            
            
        
        Returns: v1beta3_Namespace
        """

        allParams = ['name']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method readNamespace" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_Namespace')
        return responseObject
        
        
        
    
    def replaceNamespace(self, **kwargs):
        """replace the specified Namespace

        Args:
            
            name, str: name of the Namespace (required)
            
            
            body, V1beta3_Namespace:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method replaceNamespace" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def deleteNamespace(self, **kwargs):
        """delete a Namespace

        Args:
            
            name, str: name of the Namespace (required)
            
            
            body, V1beta3_DeleteOptions:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method deleteNamespace" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def patchNamespace(self, **kwargs):
        """partially update the specified Namespace

        Args:
            
            name, str: name of the Namespace (required)
            
            
            body, V1beta3_Namespace:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method patchNamespace" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PATCH'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = 'application/json-patch+json,application/merge-patch+json,application/strategic-merge-patch+json,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def replaceNamespace(self, **kwargs):
        """replace the specified Namespace

        Args:
            
            name, str: name of the Namespace (required)
            
            
            body, V1beta3_Namespace:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method replaceNamespace" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{name}/finalize'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def replaceNamespace(self, **kwargs):
        """replace the specified Namespace

        Args:
            
            name, str: name of the Namespace (required)
            
            
            body, V1beta3_Namespace:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method replaceNamespace" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/namespaces/{name}/status'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def listNode(self, **kwargs):
        """list or watch objects of kind Node

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_NodeList
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listNode" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/nodes'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_NodeList')
        return responseObject
        
        
        
    
    def createNode(self, **kwargs):
        """create a Node

        Args:
            
            body, V1beta3_Node:  (required)
            
            
        
        Returns: 
        """

        allParams = ['body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createNode" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/nodes'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def readNode(self, **kwargs):
        """read the specified Node

        Args:
            
            name, str: name of the Node (required)
            
            
        
        Returns: v1beta3_Node
        """

        allParams = ['name']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method readNode" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/nodes/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_Node')
        return responseObject
        
        
        
    
    def replaceNode(self, **kwargs):
        """replace the specified Node

        Args:
            
            name, str: name of the Node (required)
            
            
            body, V1beta3_Node:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method replaceNode" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/nodes/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def deleteNode(self, **kwargs):
        """delete a Node

        Args:
            
            name, str: name of the Node (required)
            
            
            body, V1beta3_DeleteOptions:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method deleteNode" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/nodes/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def patchNode(self, **kwargs):
        """partially update the specified Node

        Args:
            
            name, str: name of the Node (required)
            
            
            body, V1beta3_Node:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method patchNode" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/nodes/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PATCH'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = 'application/json-patch+json,application/merge-patch+json,application/strategic-merge-patch+json,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def listPersistentVolumeClaim(self, **kwargs):
        """list or watch objects of kind PersistentVolumeClaim

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_PersistentVolumeClaimList
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listPersistentVolumeClaim" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/persistentvolumeclaims'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_PersistentVolumeClaimList')
        return responseObject
        
        
        
    
    def listPersistentVolume(self, **kwargs):
        """list or watch objects of kind PersistentVolume

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_PersistentVolumeList
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listPersistentVolume" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/persistentvolumes'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_PersistentVolumeList')
        return responseObject
        
        
        
    
    def createPersistentVolume(self, **kwargs):
        """create a PersistentVolume

        Args:
            
            body, V1beta3_PersistentVolume:  (required)
            
            
        
        Returns: 
        """

        allParams = ['body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createPersistentVolume" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/persistentvolumes'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def readPersistentVolume(self, **kwargs):
        """read the specified PersistentVolume

        Args:
            
            name, str: name of the PersistentVolume (required)
            
            
        
        Returns: v1beta3_PersistentVolume
        """

        allParams = ['name']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method readPersistentVolume" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/persistentvolumes/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_PersistentVolume')
        return responseObject
        
        
        
    
    def replacePersistentVolume(self, **kwargs):
        """replace the specified PersistentVolume

        Args:
            
            name, str: name of the PersistentVolume (required)
            
            
            body, V1beta3_PersistentVolume:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method replacePersistentVolume" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/persistentvolumes/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def deletePersistentVolume(self, **kwargs):
        """delete a PersistentVolume

        Args:
            
            name, str: name of the PersistentVolume (required)
            
            
            body, V1beta3_DeleteOptions:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method deletePersistentVolume" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/persistentvolumes/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def patchPersistentVolume(self, **kwargs):
        """partially update the specified PersistentVolume

        Args:
            
            name, str: name of the PersistentVolume (required)
            
            
            body, V1beta3_PersistentVolume:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method patchPersistentVolume" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/persistentvolumes/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PATCH'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = 'application/json-patch+json,application/merge-patch+json,application/strategic-merge-patch+json,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def replacePersistentVolume(self, **kwargs):
        """replace the specified PersistentVolume

        Args:
            
            name, str: name of the PersistentVolume (required)
            
            
            body, V1beta3_PersistentVolume:  (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method replacePersistentVolume" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/persistentvolumes/{name}/status'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        
        if ('body' in params):
            bodyParam = params['body']
        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def listPod(self, **kwargs):
        """list or watch objects of kind Pod

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_PodList
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listPod" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/pods'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_PodList')
        return responseObject
        
        
        
    
    def proxyGETPod(self, **kwargs):
        """proxy GET requests to Pod

        Args:
            
            name, str: name of the Pod (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyGETPod" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/namespaces/{namespaces}/pods/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyPUTPod(self, **kwargs):
        """proxy PUT requests to Pod

        Args:
            
            name, str: name of the Pod (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyPUTPod" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/namespaces/{namespaces}/pods/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyPOSTPod(self, **kwargs):
        """proxy POST requests to Pod

        Args:
            
            name, str: name of the Pod (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyPOSTPod" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/namespaces/{namespaces}/pods/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyDELETEPod(self, **kwargs):
        """proxy DELETE requests to Pod

        Args:
            
            name, str: name of the Pod (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyDELETEPod" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/namespaces/{namespaces}/pods/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyGETPod(self, **kwargs):
        """proxy GET requests to Pod

        Args:
            
            name, str: name of the Pod (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            path:*, str: path to the resource (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'path:*']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyGETPod" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/namespaces/{namespaces}/pods/{name}/{path:*}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        
        if ('path:*' in params):
            replacement = str(self.apiClient.toPathValue(params['path:*']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'path:*' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyPUTPod(self, **kwargs):
        """proxy PUT requests to Pod

        Args:
            
            name, str: name of the Pod (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            path:*, str: path to the resource (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'path:*']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyPUTPod" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/namespaces/{namespaces}/pods/{name}/{path:*}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        
        if ('path:*' in params):
            replacement = str(self.apiClient.toPathValue(params['path:*']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'path:*' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyPOSTPod(self, **kwargs):
        """proxy POST requests to Pod

        Args:
            
            name, str: name of the Pod (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            path:*, str: path to the resource (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'path:*']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyPOSTPod" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/namespaces/{namespaces}/pods/{name}/{path:*}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        
        if ('path:*' in params):
            replacement = str(self.apiClient.toPathValue(params['path:*']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'path:*' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyDELETEPod(self, **kwargs):
        """proxy DELETE requests to Pod

        Args:
            
            name, str: name of the Pod (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            path:*, str: path to the resource (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'path:*']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyDELETEPod" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/namespaces/{namespaces}/pods/{name}/{path:*}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        
        if ('path:*' in params):
            replacement = str(self.apiClient.toPathValue(params['path:*']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'path:*' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyGETService(self, **kwargs):
        """proxy GET requests to Service

        Args:
            
            name, str: name of the Service (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyGETService" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/namespaces/{namespaces}/services/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyPUTService(self, **kwargs):
        """proxy PUT requests to Service

        Args:
            
            name, str: name of the Service (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyPUTService" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/namespaces/{namespaces}/services/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyPOSTService(self, **kwargs):
        """proxy POST requests to Service

        Args:
            
            name, str: name of the Service (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyPOSTService" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/namespaces/{namespaces}/services/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyDELETEService(self, **kwargs):
        """proxy DELETE requests to Service

        Args:
            
            name, str: name of the Service (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyDELETEService" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/namespaces/{namespaces}/services/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyGETService(self, **kwargs):
        """proxy GET requests to Service

        Args:
            
            name, str: name of the Service (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            path:*, str: path to the resource (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'path:*']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyGETService" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/namespaces/{namespaces}/services/{name}/{path:*}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        
        if ('path:*' in params):
            replacement = str(self.apiClient.toPathValue(params['path:*']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'path:*' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyPUTService(self, **kwargs):
        """proxy PUT requests to Service

        Args:
            
            name, str: name of the Service (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            path:*, str: path to the resource (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'path:*']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyPUTService" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/namespaces/{namespaces}/services/{name}/{path:*}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        
        if ('path:*' in params):
            replacement = str(self.apiClient.toPathValue(params['path:*']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'path:*' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyPOSTService(self, **kwargs):
        """proxy POST requests to Service

        Args:
            
            name, str: name of the Service (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            path:*, str: path to the resource (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'path:*']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyPOSTService" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/namespaces/{namespaces}/services/{name}/{path:*}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        
        if ('path:*' in params):
            replacement = str(self.apiClient.toPathValue(params['path:*']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'path:*' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyDELETEService(self, **kwargs):
        """proxy DELETE requests to Service

        Args:
            
            name, str: name of the Service (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            path:*, str: path to the resource (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces', 'path:*']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyDELETEService" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/namespaces/{namespaces}/services/{name}/{path:*}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        
        if ('path:*' in params):
            replacement = str(self.apiClient.toPathValue(params['path:*']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'path:*' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyGETNode(self, **kwargs):
        """proxy GET requests to Node

        Args:
            
            name, str: name of the Node (required)
            
            
        
        Returns: 
        """

        allParams = ['name']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyGETNode" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/nodes/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyPUTNode(self, **kwargs):
        """proxy PUT requests to Node

        Args:
            
            name, str: name of the Node (required)
            
            
        
        Returns: 
        """

        allParams = ['name']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyPUTNode" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/nodes/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyPOSTNode(self, **kwargs):
        """proxy POST requests to Node

        Args:
            
            name, str: name of the Node (required)
            
            
        
        Returns: 
        """

        allParams = ['name']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyPOSTNode" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/nodes/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyDELETENode(self, **kwargs):
        """proxy DELETE requests to Node

        Args:
            
            name, str: name of the Node (required)
            
            
        
        Returns: 
        """

        allParams = ['name']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyDELETENode" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/nodes/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyGETNode(self, **kwargs):
        """proxy GET requests to Node

        Args:
            
            name, str: name of the Node (required)
            
            
            path:*, str: path to the resource (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'path:*']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyGETNode" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/nodes/{name}/{path:*}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('path:*' in params):
            replacement = str(self.apiClient.toPathValue(params['path:*']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'path:*' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyPUTNode(self, **kwargs):
        """proxy PUT requests to Node

        Args:
            
            name, str: name of the Node (required)
            
            
            path:*, str: path to the resource (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'path:*']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyPUTNode" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/nodes/{name}/{path:*}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('path:*' in params):
            replacement = str(self.apiClient.toPathValue(params['path:*']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'path:*' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyPOSTNode(self, **kwargs):
        """proxy POST requests to Node

        Args:
            
            name, str: name of the Node (required)
            
            
            path:*, str: path to the resource (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'path:*']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyPOSTNode" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/nodes/{name}/{path:*}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('path:*' in params):
            replacement = str(self.apiClient.toPathValue(params['path:*']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'path:*' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def proxyDELETENode(self, **kwargs):
        """proxy DELETE requests to Node

        Args:
            
            name, str: name of the Node (required)
            
            
            path:*, str: path to the resource (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'path:*']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method proxyDELETENode" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/proxy/nodes/{name}/{path:*}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('path:*' in params):
            replacement = str(self.apiClient.toPathValue(params['path:*']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'path:*' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def redirectPod(self, **kwargs):
        """redirect GET request to Pod

        Args:
            
            name, str: name of the Pod (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method redirectPod" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/redirect/namespaces/{namespaces}/pods/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def redirectService(self, **kwargs):
        """redirect GET request to Service

        Args:
            
            name, str: name of the Service (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
        
        Returns: 
        """

        allParams = ['name', 'namespaces']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method redirectService" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/redirect/namespaces/{namespaces}/services/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def redirectNode(self, **kwargs):
        """redirect GET request to Node

        Args:
            
            name, str: name of the Node (required)
            
            
        
        Returns: 
        """

        allParams = ['name']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method redirectNode" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/redirect/nodes/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = '*/*'
        headerParams['Content-Type'] = '*/*,'

        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        
        
    
    def listReplicationController(self, **kwargs):
        """list or watch objects of kind ReplicationController

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_ReplicationControllerList
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listReplicationController" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/replicationcontrollers'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_ReplicationControllerList')
        return responseObject
        
        
        
    
    def listResourceQuota(self, **kwargs):
        """list or watch objects of kind ResourceQuota

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_ResourceQuotaList
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listResourceQuota" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/resourcequotas'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_ResourceQuotaList')
        return responseObject
        
        
        
    
    def listSecret(self, **kwargs):
        """list or watch objects of kind Secret

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_SecretList
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listSecret" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/secrets'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_SecretList')
        return responseObject
        
        
        
    
    def listService(self, **kwargs):
        """list or watch objects of kind Service

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: v1beta3_ServiceList
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listService" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/services'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'v1beta3_ServiceList')
        return responseObject
        
        
        
    
    def watchEndpointslist(self, **kwargs):
        """watch individual changes to a list of Endpoints

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchEndpointslist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/endpoints'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchEventlist(self, **kwargs):
        """watch individual changes to a list of Event

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchEventlist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/events'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchLimitRangelist(self, **kwargs):
        """watch individual changes to a list of LimitRange

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchLimitRangelist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/limitranges'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchNamespacelist(self, **kwargs):
        """watch individual changes to a list of Namespace

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchNamespacelist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchEndpointslist(self, **kwargs):
        """watch individual changes to a list of Endpoints

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchEndpointslist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces/{namespaces}/endpoints'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchEndpoints(self, **kwargs):
        """watch changes to an object of kind Endpoints

        Args:
            
            name, str: name of the Endpoints (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['name', 'namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchEndpoints" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces/{namespaces}/endpoints/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchEventlist(self, **kwargs):
        """watch individual changes to a list of Event

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchEventlist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces/{namespaces}/events'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchEvent(self, **kwargs):
        """watch changes to an object of kind Event

        Args:
            
            name, str: name of the Event (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['name', 'namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchEvent" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces/{namespaces}/events/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchLimitRangelist(self, **kwargs):
        """watch individual changes to a list of LimitRange

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchLimitRangelist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces/{namespaces}/limitranges'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchLimitRange(self, **kwargs):
        """watch changes to an object of kind LimitRange

        Args:
            
            name, str: name of the LimitRange (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['name', 'namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchLimitRange" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces/{namespaces}/limitranges/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchPersistentVolumeClaimlist(self, **kwargs):
        """watch individual changes to a list of PersistentVolumeClaim

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchPersistentVolumeClaimlist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces/{namespaces}/persistentvolumeclaims'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchPersistentVolumeClaim(self, **kwargs):
        """watch changes to an object of kind PersistentVolumeClaim

        Args:
            
            name, str: name of the PersistentVolumeClaim (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['name', 'namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchPersistentVolumeClaim" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces/{namespaces}/persistentvolumeclaims/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchPodlist(self, **kwargs):
        """watch individual changes to a list of Pod

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchPodlist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces/{namespaces}/pods'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchPod(self, **kwargs):
        """watch changes to an object of kind Pod

        Args:
            
            name, str: name of the Pod (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['name', 'namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchPod" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces/{namespaces}/pods/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchReplicationControllerlist(self, **kwargs):
        """watch individual changes to a list of ReplicationController

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchReplicationControllerlist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces/{namespaces}/replicationcontrollers'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchReplicationController(self, **kwargs):
        """watch changes to an object of kind ReplicationController

        Args:
            
            name, str: name of the ReplicationController (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['name', 'namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchReplicationController" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces/{namespaces}/replicationcontrollers/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchResourceQuotalist(self, **kwargs):
        """watch individual changes to a list of ResourceQuota

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchResourceQuotalist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces/{namespaces}/resourcequotas'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchResourceQuota(self, **kwargs):
        """watch changes to an object of kind ResourceQuota

        Args:
            
            name, str: name of the ResourceQuota (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['name', 'namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchResourceQuota" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces/{namespaces}/resourcequotas/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchSecretlist(self, **kwargs):
        """watch individual changes to a list of Secret

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchSecretlist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces/{namespaces}/secrets'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchSecret(self, **kwargs):
        """watch changes to an object of kind Secret

        Args:
            
            name, str: name of the Secret (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['name', 'namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchSecret" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces/{namespaces}/secrets/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchServicelist(self, **kwargs):
        """watch individual changes to a list of Service

        Args:
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchServicelist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces/{namespaces}/services'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchService(self, **kwargs):
        """watch changes to an object of kind Service

        Args:
            
            name, str: name of the Service (required)
            
            
            namespaces, str: object name and auth scope, such as for teams and projects (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['name', 'namespaces', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchService" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces/{namespaces}/services/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        
        if ('namespaces' in params):
            replacement = str(self.apiClient.toPathValue(params['namespaces']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'namespaces' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchNamespace(self, **kwargs):
        """watch changes to an object of kind Namespace

        Args:
            
            name, str: name of the Namespace (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['name', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchNamespace" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/namespaces/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchNodelist(self, **kwargs):
        """watch individual changes to a list of Node

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchNodelist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/nodes'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchNode(self, **kwargs):
        """watch changes to an object of kind Node

        Args:
            
            name, str: name of the Node (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['name', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchNode" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/nodes/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchPersistentVolumeClaimlist(self, **kwargs):
        """watch individual changes to a list of PersistentVolumeClaim

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchPersistentVolumeClaimlist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/persistentvolumeclaims'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchPersistentVolumelist(self, **kwargs):
        """watch individual changes to a list of PersistentVolume

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchPersistentVolumelist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/persistentvolumes'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchPersistentVolume(self, **kwargs):
        """watch changes to an object of kind PersistentVolume

        Args:
            
            name, str: name of the PersistentVolume (required)
            
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['name', 'fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchPersistentVolume" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/persistentvolumes/{name}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        
        if ('name' in params):
            replacement = str(self.apiClient.toPathValue(params['name']))
            replacement = urllib.quote(replacement)
            resourcePath = resourcePath.replace('{' + 'name' + '}',
                                                replacement)
        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchPodlist(self, **kwargs):
        """watch individual changes to a list of Pod

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchPodlist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/pods'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchReplicationControllerlist(self, **kwargs):
        """watch individual changes to a list of ReplicationController

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchReplicationControllerlist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/replicationcontrollers'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchResourceQuotalist(self, **kwargs):
        """watch individual changes to a list of ResourceQuota

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchResourceQuotalist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/resourcequotas'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchSecretlist(self, **kwargs):
        """watch individual changes to a list of Secret

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchSecretlist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/secrets'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    
    def watchServicelist(self, **kwargs):
        """watch individual changes to a list of Service

        Args:
            
            fieldSelector, str: a selector to restrict the list of returned objects by their fields; defaults to everything (required)
            
            
            labelSelector, str: a selector to restrict the list of returned objects by their labels; defaults to everything (required)
            
            
            resourceVersion, str: when specified with a watch call, shows changes that occur after that particular version of a resource; defaults to changes from the beginning of history (required)
            
            
            watch, bool: watch for changes to the described resources and return them as a stream of add, update, and remove notifications; specify resourceVersion (required)
            
            
        
        Returns: json_WatchEvent
        """

        allParams = ['fieldSelector', 'labelSelector', 'resourceVersion', 'watch']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method watchServicelist" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1beta3/watch/services'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}
        formParams = {}
        files = {}
        bodyParam = None

        headerParams['Accept'] = 'application/json'
        headerParams['Content-Type'] = '*/*,'

        
        if ('fieldSelector' in params):
            queryParams['fieldSelector'] = self.apiClient.toPathValue(params['fieldSelector'])
        
        if ('labelSelector' in params):
            queryParams['labelSelector'] = self.apiClient.toPathValue(params['labelSelector'])
        
        if ('resourceVersion' in params):
            queryParams['resourceVersion'] = self.apiClient.toPathValue(params['resourceVersion'])
        
        if ('watch' in params):
            queryParams['watch'] = self.apiClient.toPathValue(params['watch'])
        

        

        

        

        

        postData = (formParams if formParams else bodyParam)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams, files=files)

        
        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'json_WatchEvent')
        return responseObject
        
        
        
    


